---
title: "RNASeq Report"
output: html_notebook
params:
---

```{r setup, include=FALSE}
root <- rprojroot::find_root(".git/index")
knitr::opts_knit$set(root.dir = root)
library(tximport)
library(tidyverse)
library("DESeq2")
library(stringr)
require(rtracklayer)
library(ggrepel)
library(patchwork) # For combining plots
library(biomaRt)
library(ggpubr)
library(openxlsx)
library(ggh4x)
library(legendry)
source(file.path(root, "code", "09_RNASeq", "go_analysis.R"))
```


```{r}
library(dplyr)
library(readr)
library(tibble)

# ----------------------------
# 1) Metadata + unified filters
# ----------------------------
sample_data <- file.path(root, "input_data/09_RNASeq/rnaseq_metadata.txt")
coldata <- read.table(sample_data, header = TRUE, sep = "", check.names = FALSE)

# Keep one row per PN/SpecNo combo; drop raw read paths
pheno_data <- coldata %>%
  dplyr::select(-R1, -R2) %>%
  distinct()

# Define filters in one place
gwas_1_set <- c("APA", "BAM", "BEN", "MOV", "BIR", "DOG", "DOV", "BAVA", "BIK", "APA", "BEN")
values_to_drop <- c("PK1", "PK2", "PK3") # <- set as needed

# Apply both filters at once
gw1_pheno_data <- pheno_data %>%
  filter(Population %in% gwas_1_set) %>%
  filter(!SpecNo %in% values_to_drop)

# Factors (optional: lock levels to what remains)
gw1_pheno_data <- gw1_pheno_data %>%
  mutate(
    Population = factor(Population, levels = sort(unique(Population))),
    Phenotype  = factor(Phenotype)
  )

# Ensure PN exists and is unique; use as rownames for colData
stopifnot("PN" %in% names(gw1_pheno_data))
if (anyDuplicated(gw1_pheno_data$PN) > 0) {
  dupPN <- gw1_pheno_data$PN[duplicated(gw1_pheno_data$PN)]
  stop(paste("Duplicate PN values found:", paste(unique(dupPN), collapse = ", ")))
}
rownames(gw1_pheno_data) <- gw1_pheno_data$PN

# Tidy pheno table keyed by PN (no rownames_to_column to avoid PN dup)
pheno_tbl <- as.data.frame(gw1_pheno_data)

population_groups <- c(
  "APA"  = "TP1",
  "BAM"  = "BP1",
  "BEN"  = "TP1",
  "MOV"  = "TP_OUT",
  "BIR"  = "BP3",
  "DOG"  = "TP2",
  "DOV"  = "TP2",
  "BAVA" = "BP2",
  "BIK"  = "BP2"
)

# ----------------------------
# 2) Files for tximport (names MUST be PN)
# ----------------------------
gw1_genes_files <- file.path(
  root, "output_data/09_RNASeq/quantification",
  paste0(gw1_pheno_data$SpecNo, ".isoforms.results")
)
names(gw1_genes_files) <- gw1_pheno_data$PN # critical: names == PN

# Optional: quick file existence check
missing <- gw1_genes_files[!file.exists(gw1_genes_files)]
if (length(missing) > 0) {
  warning(paste(
    "Missing quant files for PN:",
    paste(names(missing), collapse = ", ")
  ))
}
```

```{r}
# ----------------------------
# 3) tximport and DESeq2 object
# ----------------------------
gw1_genes.rsem <- tximport(
  files = gw1_genes_files,
  type = "none",
  txIn = TRUE,
  txOut = TRUE,
  geneIdCol = "gene_id",
  txIdCol = "transcript_id",
  abundanceCol = "TPM",
  countsCol = "expected_count",
  lengthCol = "effective_length",
  importer = function(x) readr::read_tsv(x)
)

# Fix zero lengths (rare RSEM artifact)
gw1_genes.rsem$length[gw1_genes.rsem$length == 0] <- 0.01

gw1_dds <- DESeqDataSetFromTximport(
  txi     = gw1_genes.rsem,
  colData = gw1_pheno_data,
  design  = ~Population
)

# Sanity check: columns (samples) must match PN
stopifnot(identical(colnames(gw1_dds), rownames(gw1_pheno_data)))

# Filter low-count genes and fit model
keep <- rowSums(counts(gw1_dds)) >= 10
gw1_dds <- gw1_dds[keep, ]
gw1_dds <- DESeq(gw1_dds)
```

```{r}
overlapping_annotations <- fread(file.path(root, "output_data/06_Association/PKINGS_ALL_WOB_EXCLUDED", "PKINGS_ALL_WOB_EXCLUDED_TRANSCRIPTS_IN_PEAKS_manual_annos_add.txt"))

## Get Peaks Data
peaks.file <- file.path(root, "output_data/06_Association/PKINGS_ALL_WOB_EXCLUDED/PKINGS_ALL_WOB_EXCLUDED_PEAKS.bed")
peaks.bed <- read.table(peaks.file)
names(peaks.bed) <- c("chrom", "start", "end", "peak", "idx_p", "idx_bp")
peaks.bed$chrom <- paste0("chr", peaks.bed$chrom)
peaks.bed <- peaks.bed[order(peaks.bed$peak), ]

gr_anno <- GRanges(
  overlapping_annotations$seqnames,
  IRanges(overlapping_annotations$start, overlapping_annotations$end)
)
gr_peaks <- GRanges(peaks.bed$chrom, IRanges(peaks.bed$start, peaks.bed$end))

## 1) exact overlaps
hits <- findOverlaps(gr_anno, gr_peaks, ignore.strand = TRUE)
peak_vec <- rep(NA_integer_, nrow(overlapping_annotations))
if (length(hits) > 0) {
  first_by_q <- tapply(subjectHits(hits), queryHits(hits), function(x) x[1])
  peak_vec[as.integer(names(first_by_q))] <- peaks.bed$peak[unlist(first_by_q)]
}

## 2) nearest fallback within 25 kb only where still NA
need <- which(is.na(peak_vec))
if (length(need)) {
  nearest_idx <- nearest(gr_anno[need], gr_peaks, select = "arbitrary")
  dists <- distance(gr_anno[need], gr_peaks[nearest_idx])
  use <- which(!is.na(nearest_idx) & dists <= 25000)
  peak_vec[need[use]] <- peaks.bed$peak[nearest_idx[use]]
}

## 3) assigned_name column
assigned_name <- ifelse(
  is.na(overlapping_annotations$manual_name) | overlapping_annotations$manual_name == "",
  overlapping_annotations$gene,
  overlapping_annotations$manual_name
)

## 4) final table
overlapping_with_peak <- cbind(
  overlapping_annotations,
  peak = peak_vec,
  assigned_name = assigned_name
)
```

```{r}
tx_abs_expr <- as.matrix(gw1_genes.rsem$abundance) # genes x samples (TPM)
tx_abs_expr <- tx_abs_expr[, colnames(gw1_dds), drop = FALSE] # align sample order

## -----------------------------------------------------------
## 2) Build transcript ↔ gene/peak mapping from your overlap table
##     - Use overlapping_with_peak$ID as the transcript label to display
##     - Group by gene (assigned_name fallback) and by peak
##     - Make matching robust to version suffixes in transcript IDs
## -----------------------------------------------------------
overlap_tbl <- overlapping_with_peak %>%
  mutate(
    transcript_label = trimws(as.character(ID)), # what you want to DISPLAY
    gene_symbol = trimws(as.character(dplyr::coalesce(assigned_name, gene))),
    peak = as.integer(peak)
  ) %>%
  filter(!is.na(transcript_label), transcript_label != "")

# Some quant tools keep versioned transcript rownames (XM_XXXXX.2); normalize both sides
strip_ver <- function(x) sub("\\.\\d+$", "", x)
tx_rownames <- rownames(tx_abs_expr)
tx_rownames_nov <- strip_ver(tx_rownames)

# Try to match by exact first, then by versionless
overlap_tbl <- overlap_tbl %>%
  mutate(
    tr_exact_hit = match(transcript_label, tx_rownames),
    tr_nov_hit   = match(strip_ver(transcript_label), tx_rownames_nov),
    expr_row_idx = ifelse(!is.na(tr_exact_hit), tr_exact_hit, tr_nov_hit)
  ) %>%
  filter(!is.na(expr_row_idx)) %>%
  mutate(expr_row_id = tx_rownames[expr_row_idx]) %>%
  distinct(expr_row_id, transcript_label, gene_symbol, peak)

sel_ids <- intersect(overlap_tbl$expr_row_id, rownames(tx_abs_expr))
stopifnot(length(sel_ids) > 0)
overlap_tbl <- overlap_tbl %>% filter(expr_row_id %in% sel_ids)
```

```{r}
peak_by_id <- setNames(overlap_tbl$peak, overlap_tbl$expr_row_id)
label_by_id <- setNames(overlap_tbl$transcript_label, overlap_tbl$expr_row_id) # rownames in heatmap
gene_by_id <- setNames(overlap_tbl$gene_symbol, overlap_tbl$expr_row_id)

peak_levels <- sort(unique(overlap_tbl$peak))
# Order: by peak, then by gene, then EO-strict yes first, then EO median desc, then transcript label
ord_rows <- order(
  factor(peak_by_id[sel_ids], levels = peak_levels),
  gene_by_id[sel_ids],
  label_by_id[sel_ids]
)
sel_ids_ord <- sel_ids[ord_rows]
```


```{r, fig.height=12}
df <- as.data.frame(colData(gw1_dds)[, c("Population")])
colnames(df) <- "Population"

pop_fac <- factor(df$Population)
ord_cols <- order(pop_fac)

## -----------------------------------------------------------
## 5) Plotting matrix and row splits (split by Peak and by Gene)
## -----------------------------------------------------------
mat_abs <- log2(tx_abs_expr[sel_ids_ord, colnames(gw1_dds), drop = FALSE] + 1)
# mat_abs <- mat_abs[, ord_cols, drop = FALSE]
rownames(mat_abs) <- label_by_id[sel_ids_ord] # <-- show transcript ID

row_split_df <- data.frame(
  Peak = factor(peak_by_id[sel_ids_ord], levels = peak_levels),
  Gene = factor(gene_by_id[sel_ids_ord]),
  row.names = rownames(mat_abs),
  check.names = FALSE
)

## -----------------------------------------------------------
## 6) Color function (kept your warm-biased quantile mapping)
## -----------------------------------------------------------
qs <- as.numeric(quantile(as.vector(mat_abs), probs = c(0, .20, .40, .70, .95), na.rm = TRUE))
col_fun_abs <- circlize::colorRamp2(
  qs,
  c("#ffffff", "#fff5eb", "#fdd0a2", "#f16913", "#b30000")
)

## -----------------------------------------------------------
## 7) Draw the heatmap
##    - No clustering; columns split by tissue; rows split by Peak and Gene
## -----------------------------------------------------------
ht <- ComplexHeatmap::Heatmap(
  mat_abs,
  name = "log2(TPM+1)",
  col = col_fun_abs,
  show_row_names = TRUE,
  row_names_gp = grid::gpar(fontsize = 9),
  show_column_names = FALSE,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  row_split = row_split_df, # <-- split by Peak then Gene
  row_title_rot = 0,
  row_title_gp = grid::gpar(fontsize = 9, fontface = "bold"),
  column_split = pop_fac[ord_cols],
  column_gap = grid::unit(2, "mm"),
  row_gap = grid::unit(1.5, "mm"),
  border = FALSE,
)

ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
```

```{r per_gene_isoform_boxplots, message=FALSE, warning=FALSE, fig.width=12, fig.height=6}
# Keep only transcripts we actually quantified; carry peak and gene metadata
valid_ids <- intersect(overlap_tbl$expr_row_id, rownames(tx_abs_expr))
plot_map <- overlap_tbl %>%
  dplyr::filter(expr_row_id %in% valid_ids) %>%
  dplyr::select(expr_row_id, transcript_label, gene_symbol, peak) %>%
  dplyr::distinct()

# Long-format expression at transcript level, joined to gene/isoform labels, Peak, and Population
expr_long <- as.data.frame(tx_abs_expr[plot_map$expr_row_id, , drop = FALSE]) %>%
  tibble::rownames_to_column("expr_row_id") %>%
  tidyr::pivot_longer(-expr_row_id, names_to = "PN", values_to = "TPM") %>%
  dplyr::left_join(plot_map, by = "expr_row_id") %>%
  dplyr::left_join(pheno_tbl %>% dplyr::select(PN, Population), by = "PN") %>%
  dplyr::mutate(
    Population = factor(Population, levels = levels(gw1_pheno_data$Population)),
    log2_TPM1  = log2(TPM + 1)
  ) %>%
  dplyr::filter(!is.na(Population), !is.na(peak))

# ---- Add population groups + ordering ----
group_order <- c("TP1", "TP2", "TP_OUT", "BP1", "BP2", "BP3")

expr_long <- expr_long %>%
  mutate(
    PopGroup = population_groups[as.character(Population)],
    PopGroup = factor(PopGroup, levels = group_order)
  )

# Order populations within each group (keeps your provided mapping order)
pop_order <- unlist(lapply(group_order, function(g) {
  names(population_groups)[population_groups == g]
}))
expr_long <- expr_long %>%
  mutate(Population = factor(Population, levels = pop_order))


# Helper to make a single-peak plot (faceted by gene)
make_peak_plot <- function(pk) {
  # Filter to one peak and keep rows with a valid group
  df_p <- expr_long %>%
    dplyr::filter(.data$peak == pk, !is.na(.data$PopGroup))

  # Legend labels: "GENE — isoform"
  labs_tbl <- df_p %>%
    dplyr::distinct(transcript_label, gene_symbol) %>%
    dplyr::arrange(gene_symbol, transcript_label)
  lab_map <- stats::setNames(
    paste0(labs_tbl$gene_symbol, " \u2014 ", labs_tbl$transcript_label),
    labs_tbl$transcript_label
  )

  # Populations present (in your global order) + their groups
  pops_present   <- as.character(pop_order[pop_order %in% df_p$Population])
  groups_present <- as.character(unname(population_groups[pops_present]))

  # Display-safe group text so "TP_OUT" doesn't split across lines
  groups_disp <- gsub("_", "\u2011", groups_present)  # non-breaking hyphen

  # Relevel + build nested x label as "Population::Group" (item first, group second)
  df_p <- df_p %>%
    dplyr::mutate(
      Population    = factor(Population, levels = pops_present),
      PopGroup      = factor(PopGroup, levels = c("TP1","TP2","TP_OUT","BP1","BP2","BP3")),
      PopGroup_disp = groups_disp[ match(as.character(Population), pops_present) ],
      x_nested      = paste(as.character(Population), PopGroup_disp, sep = "::")
    )

  # Lock x order to ensure adjacent populations with same group are contiguous
  x_levels <- paste(pops_present, groups_disp, sep = "::")

  # Positions for dashed separators between group blocks
  r <- rle(groups_disp)
  grp_ends <- cumsum(r$lengths)
  vlines_x <- if (length(grp_ends) > 1) grp_ends[-length(grp_ends)] + 0.5 else numeric(0)

  pd <- ggplot2::position_dodge2(width = 0.6, preserve = "single")

  ggplot(df_p, aes(x = x_nested, y = TPM, color = transcript_label)) +
    geom_boxplot(outlier.shape = NA, position = pd, na.rm = TRUE) +
    geom_jitter(
      alpha = 0.70, size = 1.8, shape = 16, na.rm = TRUE,
      position = ggplot2::position_jitterdodge(jitter.width = 0.15, jitter.height = 0, dodge.width = 0.6)
    ) +
    facet_wrap(~ gene_symbol, nrow = 1, scales = "fixed") +
    # Merge by the *later* part of "Population::Group" (i.e., Group)
    scale_x_discrete(limits = x_levels, drop = FALSE) +
    guides(
      x = legendry::guide_axis_nested(key = "::", angle = 45),
      color = guide_legend(title = "Isoforms by gene", byrow = TRUE)
    ) +
    { if (length(vlines_x)) geom_vline(xintercept = vlines_x, linetype = "dashed") } +
    scale_color_discrete(breaks = names(lab_map), labels = lab_map) +
    labs(
      title = paste0("Peak ", pk, " — isoform TPM by population"),
      x = "Population (top row = group)",
      y = "TPM",
      color = "Isoform"
    ) +
    coord_cartesian(clip = "off") +
    theme_bw(base_size = 11) +
    theme(
      legend.position = "right",
      axis.text.x  = element_text(margin = margin(t = 10)),
      axis.title.x = element_text(margin = margin(t = 16)),
      plot.margin  = margin(t = 24, r = 16, b = 28, l = 16),
      strip.background = element_rect(fill = NA, colour = NA),
      strip.text      = element_text(face = "bold"),
      panel.spacing.x = unit(6, "mm")
    )
}



# Build list of plots, one per peak
peaks_for_plots <- sort(unique(plot_map$peak))
plots_by_peak <- lapply(peaks_for_plots, make_peak_plot)
names(plots_by_peak) <- paste0("Peak_", peaks_for_plots)

# Print all plots to the notebook (one after another)
for (pk in peaks_for_plots) {
  print(plots_by_peak[[paste0("Peak_", pk)]])
}

# Optional: save a multi-page PDF (one page per peak)
# plots_dir <- file.path(root, "output_data", "09_RNASeq", "plots")
# dir.create(plots_dir, recursive = TRUE, showWarnings = FALSE)
# pdf_fn <- file.path(plots_dir, "peaks_faceted_by_gene_isoform_boxplots.pdf")
# pdf(pdf_fn, width = 12, height = 6)
# for (pk in peaks_for_plots) {
#   print(plots_by_peak[[paste0("Peak_", pk)]])
# }
# dev.off()
# message("Saved per-peak faceted plots to: ", pdf_fn)
```
